package session

import (
	"context"
	"crypto/rand"
	"fmt"
	"net/http"
	"time"
)

const (
	idKey  = ".id"
	idSize = 16
)

// Store defines the contract for implementing different session data stores.
type Store interface {
	Open() error
	Close() error
	Set(key string, value interface{}) error
	Get(key string) interface{}
	Delete(key string) error
}

// handler represents a secure session cookie.
type handler struct {
	*http.Cookie
	// keys is the key used to encrypt and authenticate the session cookie's value
	keys []string
	// store holds an instance for the concrete session data store implementation
	store Store
}

// http://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html
type option func(*handler)

// WithName allows setting the cookie name for storing the session.
func WithName(n string) option {
	return func(h *handler) {
		h.Name = n
	}
}

// WithDomain allows setting the cookie name for storing the session.
func WithDomain(d string) option {
	return func(h *handler) {
		h.Domain = d
	}
}

// WithSecretKey allows to configure the secret key to encrypt and authenticate the session data.
func WithSecretKey(k ...string) option {
	return func(h *handler) {
		h.keys = k
	}
}

// WithMaxAge allows to set the duration of the session.
func WithMaxAge(d time.Duration) option {
	return func(h *handler) {
		h.MaxAge = int(d.Seconds())
		h.Expires = time.Now().Add(d)
	}
}

// Set assigns a value to a specific key.
func (h *handler) Set(key string, value interface{}) error {
	return h.store.Set(key, value)
}

// Get retrieves the given key's value from the session store.
func (h *handler) Get(key string) interface{} {
	return h.store.Get(key)
}

// Delete removes the given key's value from the session store.
func (h *handler) Delete(key string) error {
	return h.store.Delete(key)
}

func (h *handler) Destroy() {
	// unset h.values
	// reset session ID
	// set expires to current's date
	// set maxAge to -1
	// call h.store.Destroy
}

// ResetID is a convenient function to help prevent session fixation attacks. After
// a successful login, a new session ID should be generated by calling this function.
func (h *handler) ResetID() {
	h.store.Set(idKey, genID(idSize))
}

func (h *handler) Open(r *http.Request) error {
	cookie, err := r.Cookie(h.Name)
	if err != nil {
		h.ResetID()
	} else {
		h.Cookie = cookie
	}

	if r.TLS != nil {
		h.Secure = true
	}

	return h.store.Open()
}

func (h *handler) Close(w http.ResponseWriter) error {
	http.SetCookie(w, h.Cookie)
	return h.store.Close()
}

// Handler verifies and creates new sessions. If a session is found and valid,
// it is attached to the Request's context for further modification or retrieval by other
// handlers.
func Handler(h http.Handler, opts ...option) http.Handler {
	session := new(handler)
	session.Cookie = new(http.Cookie)
	session.Name = "hs"
	session.HttpOnly = true
	session.MaxAge = 86400 // 1 day

	for _, opt := range opts {
		opt(session)
	}

	if len(session.keys) == 0 {
		panic("session: at least one secret key is required")
	}

	if session.store == nil {
		session.store = &CookieStore{
			Cookie: session.Cookie,
			Keys:   session.keys,
		}
	}

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		session.Open(r)
		defer session.Close(w)

		ctx := newContext(r.Context(), session)
		h.ServeHTTP(w, r.WithContext(ctx))
	})
}

// sessionKey is the key used to store the session instance in the request's context.
type sessionKey struct{}

// newContext returns a new context with the provided session inside.
func newContext(ctx context.Context, session *handler) context.Context {
	return context.WithValue(ctx, sessionKey{}, session)
}

// FromContext extracts the session from the given context.
func FromContext(ctx context.Context) (session *handler, ok bool) {
	session, ok = ctx.Value(sessionKey{}).(*handler)
	return
}

// genID returns a random string
func genID(size int) string {
	b := make([]byte, size)
	_, err := rand.Read(b)
	if err != nil {
		return ""
	}

	return fmt.Sprintf("%x", b)
}
