package session

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/pkg/errors"
	"github.com/vmihailenco/msgpack"
	"golang.org/x/crypto/nacl/secretbox"
)

// TODO(c4milo): Review for potential data race conditions
const (
	// https://www.owasp.org/index.php/Insufficient_Session-ID_Length
	idSize = 32 // 256 bits
)

// Store defines the contract for implementing different session data stores.
type Store interface {
	// Load retrieves opaque session data from backing store
	Load(id string) ([]byte, error)
	// Saves persists opaque session data to backing store
	Save(id string, data []byte) error
	// Destroy removes the session altogether from backing store
	Destroy(id string) error
}

// Session represents a secure session cookie. By default, it stores session data in the
// session cookie. If a Store is provided, only the session ID is stored in the session cookie.
type Session struct {
	*http.Cookie
	// keys is the key used to encrypt and authenticate the session cookie's value
	Keys []string
	// data is where the session data is temporarly loaded to for manipulation,
	// during the request-response lifecycle.
	data map[interface{}]interface{}
	// isDirty determines whether the session data must be save or not.
	isDirty bool
	// store holds an instance for a concrete session data store implementation
	store Store
}

// http://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html
type option func(*Session)

// WithName allows setting the cookie name for storing the session.
func WithName(n string) option {
	return func(s *Session) {
		s.Name = n
	}
}

// WithDomain allows setting the cookie name for storing the session.
func WithDomain(d string) option {
	return func(s *Session) {
		s.Domain = d
	}
}

// WithStore sets a specific backing store for session data. By default, the built-in Cookie Store is used.
func WithStore(store Store) option {
	return func(s *Session) {
		s.store = store
	}
}

// WithSecretKey allows to configure the secret key to encrypt and authenticate the session data.
// Key rotation is supported, the left-most key is always the current key.
func WithSecretKey(k ...string) option {
	return func(s *Session) {
		s.Keys = k
	}
}

// WithMaxAge allows to set the duration of the session.
func WithMaxAge(d time.Duration) option {
	return func(s *Session) {
		s.MaxAge = int(d.Seconds())
		s.Expires = time.Now().Add(d)
	}
}

// Set assigns a value to a specific key.
func (s *Session) Set(key string, value interface{}) error {
	s.isDirty = true

	s.data[key] = value
	return nil
}

// Get retrieves the given key's value from the session store.
func (s *Session) Get(key string) interface{} {
	return s.data[key]
}

// Delete removes the given key's value from the session store.
func (s *Session) Delete(key string) error {
	s.isDirty = true

	delete(s.data, key)
	return nil
}

// Destroy removes session data altogether from an external Store as well as from
// the user's browser
func (s *Session) Destroy() {
	s.MaxAge = -1
	s.Expires = time.Now()
	s.Value = ""
	s.data = make(map[interface{}]interface{})

	if s.store != nil {
		s.store.Destroy(s.Value)
	}
	s.isDirty = true
}

// ResetID is a convenient function to help prevent session fixation attacks. After
// a successful login, a new session ID should be generated by calling this function.
func (s *Session) ResetID() {
	if s.store != nil {
		s.isDirty = true
		s.Value = genID(idSize)
	}
}

// Load loads the session data, either form the built-in cookie store or an external Store
func (s *Session) Load(r *http.Request) error {
	s.isDirty = false

	cookie, err := r.Cookie(s.Name)
	if err != nil {
		s.ResetID()
		s.data = make(map[interface{}]interface{})
	} else {
		s.Cookie = cookie
	}

	if r.TLS != nil {
		s.Secure = true
	}

	data := []byte(s.Value)
	if s.store != nil {
		sessionID := s.Value
		data, err = s.store.Load(sessionID)
		if err != nil {
			return errors.Wrapf(err, "failed loading session ID: %s", sessionID)
		}
	}

	return s.decode(data)
}

// Save persist session data either on the built-in cookie store or an external Store
func (s *Session) Save(w http.ResponseWriter) error {
	if !s.isDirty {
		return nil
	}

	defer http.SetCookie(w, s.Cookie)

	data, err := s.encode()
	if err != nil {
		return err
	}

	if s.store != nil {
		return s.store.Save(s.Value, data)
	}

	s.Value = string(data[:])
	return nil
}

// Handler verifies and creates new sessions. If a session is found and valid,
// it is attached to the Request's context for further modification or retrieval by other
// handlers.
func Handler(h http.Handler, opts ...option) http.Handler {
	s := new(Session)
	s.Cookie = new(http.Cookie)
	s.Name = "hs"
	s.HttpOnly = true
	s.MaxAge = 86400 // 1 day
	s.isDirty = false

	for _, opt := range opts {
		opt(s)
	}

	if len(s.Keys) == 0 {
		panic("session: at least one secret key is required")
	}

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		s.Load(r)
		//	defer s.Save(w)

		ctx := newContext(r.Context(), s)
		h.ServeHTTP(w, r.WithContext(ctx))
	})
}

// encode encrypts and serializes the session cookie's data.
func (s *Session) encode() ([]byte, error) {
	if len(s.data) == 0 {
		return nil, nil
	}

	msg, err := msgpack.Marshal(s.data)
	if err != nil {
		return nil, errors.Wrapf(err, "failed encoding session data")
	}

	var nonce [24]byte
	if _, err := io.ReadFull(rand.Reader, nonce[:]); err != nil {
		return nil, errors.Wrapf(err, "failed generating nonce value")
	}

	var key [32]byte
	copy(key[:], s.Keys[0])

	box := secretbox.Seal(nonce[:], msg, &nonce, &key)

	data := make([]byte, base64.RawStdEncoding.EncodedLen(len(box)))
	base64.RawStdEncoding.Encode(data, box)

	return data, nil
}

// decode decrypts, authenticates and deserializes cookie's session data.
func (s *Session) decode(data []byte) error {
	if len(data) == 0 {
		return nil
	}

	box := make([]byte, base64.RawStdEncoding.DecodedLen(len(data)))
	if _, err := base64.RawStdEncoding.Decode(box, data); err != nil {
		return errors.Wrapf(err, "failed decoding session data")
	}

	var nonce [24]byte
	var msg []byte
	var key [32]byte
	var ok bool
	copy(nonce[:], box[:24])

	for _, k := range s.Keys {
		copy(key[:], k)
		msg, ok = secretbox.Open(nil, box[24:], &nonce, &key)
		if ok {
			if err := msgpack.Unmarshal(msg, &s.data); err != nil {
				return errors.Wrapf(err, "failed decoding session data")
			}
			return nil
		}
	}

	return errors.New("failed decrypting session data")
}

// sessionKey is the key used to store the session instance in the request's context.
type sessionKey struct{}

// newContext returns a new context with the provided session inside.
func newContext(ctx context.Context, s *Session) context.Context {
	return context.WithValue(ctx, sessionKey{}, s)
}

// FromContext extracts the session from the given context.
func FromContext(ctx context.Context) (s *Session, ok bool) {
	s, ok = ctx.Value(sessionKey{}).(*Session)
	return
}

// genID returns a random string
func genID(size int) string {
	b := make([]byte, size)
	_, err := rand.Read(b)
	if err != nil {
		return ""
	}

	return fmt.Sprintf("%x", b)
}
