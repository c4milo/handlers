package session

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/pkg/errors"
	"github.com/vmihailenco/msgpack"
	"golang.org/x/crypto/nacl/secretbox"
)

const (
	// https://www.owasp.org/index.php/Insufficient_Session-ID_Length
	idSize = 32 // 256 bits
)

// Store defines the contract for implementing different session data stores.
type Store interface {
	// Load retrieves opaque session data from backing store
	Load(id string) ([]byte, error)
	// Saves persists opaque session data to backing store
	Save(id string, data []byte) error
	// Destroy removes the session altogether from backing store
	Destroy(id string) error
}

// handler represents a secure session cookie. By default, it stores session data in the
// session cookie. If a Store is provided, only the session ID is stored in the session cookie.
type handler struct {
	*http.Cookie
	// keys is the key used to encrypt and authenticate the session cookie's value
	keys []string
	// data is where the session data is temporarly loaded to for manipulation,
	// during the request-response lifecycle.
	data map[interface{}]interface{}
	// isDirty determines whether the session data must be save or not.
	isDirty bool
	// store holds an instance for a concrete session data store implementation
	store Store
}

// http://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html
type option func(*handler)

// WithName allows setting the cookie name for storing the session.
func WithName(n string) option {
	return func(h *handler) {
		h.Name = n
	}
}

// WithDomain allows setting the cookie name for storing the session.
func WithDomain(d string) option {
	return func(h *handler) {
		h.Domain = d
	}
}

// WithStore sets a specific backing store for session data. By default, the built-in Cookie Store is used.
func WithStore(s Store) option {
	return func(h *handler) {
		h.store = s
	}
}

// WithSecretKey allows to configure the secret key to encrypt and authenticate the session data.
// Key rotation is supported, the left-most key is always the current key.
func WithSecretKey(k ...string) option {
	return func(h *handler) {
		h.keys = k
	}
}

// WithMaxAge allows to set the duration of the session.
func WithMaxAge(d time.Duration) option {
	return func(h *handler) {
		h.MaxAge = int(d.Seconds())
		h.Expires = time.Now().Add(d)
	}
}

// Set assigns a value to a specific key.
func (h *handler) Set(key string, value interface{}) error {
	h.isDirty = true

	h.data[key] = value
	return nil
}

// Get retrieves the given key's value from the session store.
func (h *handler) Get(key string) interface{} {
	return h.data[key]
}

// Delete removes the given key's value from the session store.
func (h *handler) Delete(key string) error {
	h.isDirty = true

	delete(h.data, key)
	return nil
}

func (h *handler) Destroy() {
	h.MaxAge = -1
	h.Expires = time.Now()
	h.Value = ""
	h.data = make(map[interface{}]interface{})

	if h.store != nil {
		h.store.Destroy(h.Value)
	}
	h.isDirty = true
}

// ResetID is a convenient function to help prevent session fixation attacks. After
// a successful login, a new session ID should be generated by calling this function.
func (h *handler) ResetID() {
	if h.store != nil {
		h.isDirty = true
		h.Value = genID(idSize)
	}
}

func (h *handler) Load(r *http.Request) error {
	h.isDirty = false

	cookie, err := r.Cookie(h.Name)
	if err != nil {
		h.ResetID()
	} else {
		h.Cookie = cookie
	}

	if r.TLS != nil {
		h.Secure = true
	}

	var data []byte
	if h.store != nil {
		sessionID := h.Value
		data, err = h.store.Load(sessionID)
		if err != nil {
			return errors.Wrapf(err, "failed loading session ID: %s", sessionID)
		}
	} else {
		data = []byte(h.Value)
	}

	return h.decode(data)
}

func (h *handler) Save(w http.ResponseWriter) error {
	if !h.isDirty {
		return nil
	}

	defer http.SetCookie(w, h.Cookie)

	data, err := h.encode()
	if err != nil {
		return err
	}

	if h.store != nil {
		return h.store.Save(h.Value, data)
	}

	h.Value = string(data[:])
	return nil
}

// Handler verifies and creates new sessions. If a session is found and valid,
// it is attached to the Request's context for further modification or retrieval by other
// handlers.
func Handler(h http.Handler, opts ...option) http.Handler {
	session := new(handler)
	session.Cookie = new(http.Cookie)
	session.Name = "hs"
	session.HttpOnly = true
	session.MaxAge = 86400 // 1 day
	session.isDirty = false

	for _, opt := range opts {
		opt(session)
	}

	if len(session.keys) == 0 {
		panic("session: at least one secret key is required")
	}

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		session.Load(r)
		defer session.Save(w)

		ctx := newContext(r.Context(), session)
		h.ServeHTTP(w, r.WithContext(ctx))
	})
}

// encode encrypts and serializes the session cookie's data.
func (h *handler) encode() ([]byte, error) {
	if len(h.data) == 0 {
		return nil, nil
	}

	msg, err := msgpack.Marshal(h.data)
	if err != nil {
		return nil, errors.Wrapf(err, "failed encoding session data")
	}

	var nonce [24]byte
	if _, err := io.ReadFull(rand.Reader, nonce[:]); err != nil {
		return nil, errors.Wrapf(err, "failed generating nonce value")
	}

	var key [32]byte
	copy(key[:], h.keys[0])

	box := secretbox.Seal(nonce[:], msg, &nonce, &key)

	var data []byte
	base64.StdEncoding.Encode(data, box)

	return data, nil
}

// decode decrypts, authenticates and deserializes cookie's session data.
func (h *handler) decode(data []byte) error {
	if len(data) == 0 {
		return nil
	}

	var box []byte
	if _, err := base64.StdEncoding.Decode(box, data); err != nil {
		return errors.Wrapf(err, "failed decoding session data")
	}

	var nonce [24]byte
	var msg []byte
	var key [32]byte
	var ok bool
	copy(nonce[:], box[:24])

	for _, k := range h.keys {
		copy(key[:], k)

		msg, ok = secretbox.Open(nil, box[24:], &nonce, &key)
		if ok {
			if err := msgpack.Unmarshal(msg, &h.data); err != nil {
				return errors.Wrapf(err, "failed decoding session data")
			}
			return nil
		}
	}

	return errors.New("failed decrypting session data")
}

// sessionKey is the key used to store the session instance in the request's context.
type sessionKey struct{}

// newContext returns a new context with the provided session inside.
func newContext(ctx context.Context, session *handler) context.Context {
	return context.WithValue(ctx, sessionKey{}, session)
}

// FromContext extracts the session from the given context.
func FromContext(ctx context.Context) (session *handler, ok bool) {
	session, ok = ctx.Value(sessionKey{}).(*handler)
	return
}

// genID returns a random string
func genID(size int) string {
	b := make([]byte, size)
	_, err := rand.Read(b)
	if err != nil {
		return ""
	}

	return fmt.Sprintf("%x", b)
}
